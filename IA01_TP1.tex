\documentclass[a4paper, 12pt, leqno]{report}

\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[greek,french]{babel}
\usepackage[babel=true]{csquotes}
\usepackage[top=1.5cm, bottom=2.0cm, left=2.0cm, right=2.0cm]{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{soul}
\usepackage{amssymb}
\pagestyle{plain}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{color}
\usepackage{enumerate}
\usepackage{array}
\theoremstyle{plain}
\usepackage{blkarray}
\usepackage{listings}


\newcommand{\bigO}[1]{\ensuremath{\mathop{}\mathopen{}O\mathopen{}\left(#1\right)}}
\newcommand{\smallO}[1]{\ensuremath{\mathop{}\mathopen{}o\mathopen{}\left(#1\right)}}

\title{\textsc{\textbf{Rapport TP NF16}}}
\author{\textbf{Antoine LE CALVEZ et Antoine POUILLAUDE}}

\begin{document}
    \maketitle
    \tableofcontents									
    \chapter{\'Etude des proc\'edures}		
        \section{Recherche dans un arbre.}        
            \begin{verbatim}
       int search(parbre r, int x)
            \end{verbatim}
            \begin{description}
            \item[Entrée :] L'arbre dans lequel on va rechercher et la valeur à rechercher.
            \item[Sortie :] 1 si l'élément à été trouvé, 0 sinon.
            \end{description}


        La première procédure que l'on va étudier est la procédure de recherche dans un arbre binaire de rechercher (eg : Binary Search Tree). Cet algorithme est simple et utilise la propriété des ABR pour trouver l'élément recherché. On part de la racine et en fonction du résultat de la comparaison on fait un appel récursif dans le sous-arbre droit ou gauche. Au vu des propriétés de la structure ABR, on fait la recherche, au pire, sur toute la hauteur de l'arbre. Donc, la complexité de l'algorithme est en $\Omega(1)$ si l'élément recherché est à la racine et en $\bigO(log_2{}(n))$ si l'élément est une feuille de l'arbre.
		
		
		\section{Insertion dans qui sera appelée à chaque fois que l'on souhaite insérer le tout première élément dans une liste.}     
            
            Elle va tout d'abord vérifié si la liste est bien vide et que la chaîne de caractères que l'on souhaite insérer est bien inférieur à $20$ caractères. Si ce n'est pas le cas elle renvoie $-1$. Si la liste a été prouvé comme étant vide la fonction alloue l'espace mémoire nécessaire pour un élément de la liste puis elle va assigner les valeurs correspondantes aux différents paramètres de la cellule créée.\\
            
            Le pointeur \verb+head+ de la liste pointera alors sur l'élément créé et il en sera de même pour le pointeur \verb+tail+. L'entier \verb+size+ sera incrémenté de $1$. Cette fonction effectue des choses constantes, elle n'effectue en effet que des affectations de valeurs, la complexité s'exprime donc en $\Theta(1)$. 
             
            
    		\section{Insertion au début d'une liste}
           \begin{verbatim}
        int insert_begining_list (List *list, char *data)
           \end{verbatim}
            \begin{description}
            \item[Entrée :] Un pointeur sur une structure de liste et un pointeur sur une chaine de caractère \verb+data+.
            \item[Sortie :] $-1$ si \verb+data+ est de longueur supérieure à $20$, $0$ en cas de succés à l'insertion.
            \end{description}
            
            
            Cette fonction est peu différente de la fonction d'insertion dans une liste vide. Elle va vérifié si la liste n'est pas vide et, si tel est le cas, va appeler la fonction d'insertion vu précédement. Puis elle va tester si la chaîne de caractère fait effectivement moins de $20$ caractères. 
            
            Les instructions suivantes suivent à peu de choses près le même schéma que tout à l'heure. La fonction va allouer dynamiquement l'espace mémoire pour une cellule, affecter les valeurs respectives aux différents paramètres de la cellule. Le pointeur \verb+next+ de la cellule sera initialisé avec la valeur de \verb+list->head+ alors que le pointeur \verb+previous+ sera \verb+NULL+.
            
            Par suite, la pointeur de tête de la liste sera affecté avec le nouvel élément créé. La queue restera, elle, inchangée.\\
            
            L'insertion se fait en $\Theta(1)$. En effet, les opérations effectuées par la fonction ne sont que des affectations. Il n'y a pas de parcours de la liste qui est requis. Le début de la liste est aisement accessible via le pointeur \verb+list.head+
            
            
        \section{Insertion en fin de liste}
           \begin{verbatim}
        int insert_end_list (List *list, char *data)
           \end{verbatim}
            \begin{description}
            \item[Entrée :] Un pointeur sur une structure de liste et un pointeur sur une chaine de caractère \verb+data+.
            \item[Sortie :] $-1$ si \verb+data+ est de longueur supérieure à $20$, $0$ en cas de succés à l'insertion.
            \end{description}
            Nous ne nous étendrons pas plus sur cette fonction car le fonctionnement de celle-ci est similaire à la fonction d'insertion en début de liste.\\
            
            Là encore la fonction est en $\Theta(1)$ car ce ne sont que des opérations d'affectations qui sont effectuées par cette fonction. Cette complexité est faible grâce aux propriétés des listes doublement chainées. En effet, le dernier élément est facilement accessible par le pointeur de queue de la structure de liste. En revanche, dans le cas d'une liste simplement chainée il aurait fallu parcourir toute la liste jusqu'à la fin.

        \newpage
        
        \section{Rechercher un élément à une position donnée}
           \label{search}
           \begin{verbatim}
        Element* search(List *list, int position);
           \end{verbatim}
            \begin{description}
            \item[Entrée :] Un pointeur sur une structure de liste, un entier pour la position de l'élément à rechercher.
            \item[Sortie :] Un pointeur sur l'élément recherché.
            \end{description}        

            Cette fonction est très simple. Elle va parcourir la liste en quête de l'élément recherché. Dans une boucle la fonction incrèmente un compteur en passant d'élément en élément via les pointeurs \verb+next+ des cellules, et une fois que la valeur du pointeur est égale à la position on retourne un pointeur sur l'élément sur lequel on se trouve.
            \begin{description}
            \item[Invariant de boucle :] Au début de chaque itération on a $1<i<\verb+position+ \leqslant \verb+list->size+$.
            \end{description}
            
            La complexité de cette procédure est dans le meilleur des cas en $\bigO{1}$, la cas où l'élément recherché est la tête de la liste. Dans le pire des cas l'élément que l'on recherche est en dernière position donc on va parcourir toute la liste et donc on sera en $\bigO{n}$. Au final, on a un complexité générale de $\Omega(1)$ et $\bigO{n}$.
          

        \section{Insertion à une certaine position}
           \begin{verbatim}
        int insert_after_position (List *list, char *data, int position)
           \end{verbatim}
            \begin{description}
            \item[Entrée :] Un pointeur sur une structure de liste, un pointeur sur une chaine de caractère \verb+data+ et un entier pour la position.
            \item[Sortie :] $-1$ si \verb+data+ est de longueur supérieure à $20$ et si $\verb+position+ > \verb+list->size+$ ou $\verb+position+ \leqslant 0$ , $0$ en cas de succés à l'insertion.
            \end{description}
            C'est ici que les choses sérieuses commencent. Cette fonction a pour but d'insérer un élément à une position précisé par l'entier \verb+position+ pris en paramètre. Comme précédement elle va faire les tests habituelles concernant la vacuité de la liste et la longueur de la chaine passée en arguement. Cependant, elle va de plus tester si la position désirée est dans la liste.
            
            On a pris comme convention que si $\verb+position+ = 1$ alors on insére en début de liste et si $\verb+position+ = \verb+list->size+$ alors on insére en fin de liste. Si $0<\verb+position+<\verb+list->size+$ alors on fait appel à la fonction \verb+search+ explicitée ci-dessus en section \ref{search}. 
            
            Lorsque l'élément à la position désirée est trouvé, la fonction va alors créer un nouvel élément et l'insérer après l'élément renvoyé par la fonction \verb+search+. Les différentes variables seront affectées avec les bonnes valeurs.\\
            
            Ici, dans les meilleurs cas la fonction se termine en $\bigO{1}$. C'est à dire les cas où la liste est vide, $\verb+position+ = 1$ ou $\verb+position+=\verb+list->size+$. Sinon, on est en $\bigO{n-1} \subseteq \bigO{n}$. Finalement, la complextié de cette fonction est $\Omega(1)$ et $\bigO{n}$.
        
        \newpage    
            
        \section{Suppression d'un élément}
           \begin{verbatim}
        int _remove (List *list, int position);
           \end{verbatim}
            \begin{description}
            \item[Entrée :] Un pointeur sur une structure de liste, un entier pour la position de l'élément que l'on souhaite supprimer.
            \item[Sortie :] $-1$ si $\verb+position+ > \verb+list->size+$ ou $\verb+position+ \leqslant 0$ , $0$ en cas de succés.
            \end{description}  
            Comme avec l'insertion à une position donnée on va d'abord véréfier $2$ conditions. On va tester si la liste n'est pas vide et si la position donnée est bien dans les limites de la liste. Une fois ceci vérifier on se débarasse des cas triviaux, c'est à dire si $\verb+position+ = 1$ on fait pointer la tête de la liste sur le deuxième élément puis on supprime l'élément qui précéde la nouvelle tête de liste et on met son pointeur \verb+previous+ à \verb+NULL+. On fait l'opération analogue si $\verb+position+ = \verb+list->size+$. Si $0<\verb+position+<\verb+list->size+$ on fait encore une fois appel à la fonction \verb+search+ pour trouver l'élément à supprimer puis dans l'ordre on fait :
            \begin{enumerate}
            \item On affecte au pointeur \verb+next+ de l'élément qui précède celui à supprimer la valeur du pointeur \verb+next+ dudit élément.
            \item On affecte au pointeur \verb+previous+ de l'élément qui suit celui à supprimer la valeur du pointeur \verb+previous+ dudit élément.
            \item On libère la mémoire occupée par l'élément à l'aide de l'instruction \verb+free+.
            \end{enumerate}
            Dans le cas de situation triviales la fonction se termine en $\Omega(1)$. Sinon, à nouveau on est en $\bigO{n}$. En conclusion la complexité de la fonction est $\Omega(1)$ et $\bigO{n}$.
            
            
        \section{Fonction de tri ascendant}
                        \begin{verbatim}
                    int ascending_sort (List *list);
                \end{verbatim}
            Nous en arrivons à \textit{"The Funtion"}. Le problème du tri est un problème universel et de nombreux algorithmes existent pour résoudre ce problème. Les algorithme programmé de manière naïve démontrent leur inutilité sur de grosses quantité de données mais sont néanmoins intuitif et immédiat à implementer. Leur complexité est en générale en $\bigO{n^2}$. Inutilisable, donc, lorsqu'il s'agit de traiter des millions de données. Ils existent, cependant, des algorithmes au temps d'éxécution moins prohibitif. Celui que nous avons choisi d'implémenter dans ce TP est l'un des plus connu et a été largement pompé sur wikipedia et nous l'avons adapté à nos besoins. Il s'agit, ni plus, ni moins, du très célèbre algorithme du \textbf{Tri rapide}.\\
            
            L'algorithme du tri rapide a une complexité en $\bigO{n^2}$ dans le pire des cas mais en $\bigO{nlog(n)}$ dans le meilleur des cas. Cet procédure se base sur le paradigme de \textit{"diviser pour régner"} et se déompose en deux fonctions.
                      
            
            \subsection{Fonction de partionnement}
                \begin{verbatim}
                    int partitionner(List* list, int first, int last);
                \end{verbatim}
                \begin{description}
                    \item[Entrée :] Un pointeur sur une structure de liste, deux entiers respectivement la limite inférieur et la limite supérieur des éléments à trier.
                    \item[Sortie :] Un entier représentant la position de l'élément pivot.
                \end{description}
                
                \newpage
                
                La procédure de partionnement est la plus importante dans l'implémentation du tri rapide. Elle implémente le principe de \textit{"diviser"} cité dans le paradigme ci-dessus. Elle permet en effet de partitionner la liste en fonction d'un élément appelé pivot. À la fin de l'exécution de cette fonction on aura alors une liste diviser en deux sous-listes pseudo ordonnées telles que tous les éléments d'une liste auront des variables \verb+data+ de valeurs inférieures du point de vu du code ASCII et ceux de l'autre auront des \verb+data+ supérieures. Ainsi on divise le problème en deux sous problèmes de tailles inférieurs
                
                La complexité de l'algorithme de tri rapide repose en grande partie sur cette fonction de partition et plus précisément sur le choix de l'élément pivot. En effet, si mal choisi la complexité pourra être en $\bigO{n^2}$ et le choix de cet algorithme deviendra caduque. Le pire des cas est en fait celui où l'élément pivot choisi est le plus grand de la liste. Dans ce cas la fonction ne produira qu'une seule liste de taille égale au problème de départ où tous les éléments seront forcément inférieurs à l'élément pivot. Le principe de \textit{"diviser"} n'est alors plus respecter et nous revenons au problème du tri par insertion.\\
                
                Le principe de fonctionnement de la fonction est assez compliqué à détailler et je vais tenter de faire simple. Nous commençons par l'initialisation durant laquelle nous initialisons arbitrairement l'élément pivot comme étant la queue de la liste. Ensuite, nous allons initialisé \verb+ei+ et \verb+ej+ comme des pointeurs sur les éléments au position associées. \verb+el+ est ici un élément qui ne sert à rien je dois le dire, mais il s'avère que la procédure ne fonctionne pas sans lui pour des raisons qui je le crains m'échappent. Durant la boucle, les différents éléments de la liste vont être placé dans la partition qui leur est associé. À droite pour les éléments supérieurs au pivot et à gauche sinon. Ce qui nous donne l'invariant de boucle suivant.
            \begin{description}
            \item[Invariant de boucle :]  
                      
            \begin{enumerate}
            \item Si $p \leqslant k \leqslant i$ alors $ek \leqslant ep$
            \item Si $i+1 \leqslant k \leqslant j-1$ alors $ek > ep$
            \item Si $k=el$, alors $ek=ep$
            
            \end{enumerate}
            où $ek$ représente l'élément à la position k.
            \end{description}    
            \subsection{Fonction Quicksort}
             \begin{verbatim}
                    void QuickSort(List* list, int first, int last);
                \end{verbatim}
                \begin{description}
                    \item[Entrée :] Un pointeur sur une structure de liste, deux entiers respectivement la limite inférieur et la limite supérieur des éléments à trier.
                    \item[Sortie :] Rien théoriquement mais produit une liste trier.
                \end{description}
                Cette fonction s'occupe des appels récursifs afin de trier les sous listes $1..pi-1$ et $pi+1..n$, où $pi$ est la position pivot renvoyé par la fonction de partionnement.
                
                Pour le calcul de la complexité on a dans le pire des cas, c'est à dire si on a un élément pivot mal adapté on ne divisera pas le problème en deux sous problèmes ce qui implique une complexité en $\bigO{n^2}$. En revanche, dans le meilleur des cas, si on prend l'élément médian de la liste on aura diviser le problème en deux sous problèmes de taille égale et donc une compléxité en $\bigO{nlog(n)}$.
                
                \newpage
                
        \section{Fonction de tri descendant}
         \begin{verbatim}
                    int descending_sort (List *list);
                \end{verbatim}
             
                Cette fonction est similaire à la précédante si ce n'est qu'elle fait appel à la fonction de tri ascendant pour ensuite inverser la liste en faisant appel à la fonction \verb+reverse+. La fonction \verb+reverse+ parcours la liste et inverse tous les pointeurs des cellules.\\
                
                Dans le meilleur des cas cette fonction est donc en $\bigO{n}$ et dans le pire elle est en $\bigO{n^2}$.
                
         \section{Afficher une liste}
                 \begin{verbatim}
                    void display(List *list);
                \end{verbatim}
                \begin{description}
                    \item[Entrée :] Un pointeur sur une structure de liste.
                    \item[Sortie :] Rien.
                \end{description}                
                Cette procédure va parcourir la liste est afficher les valeurs des chaines de caractère de chaque cellule. La complexité de cette procédure est donc $\Theta(n)$
         \section{Afficher une liste à l'envers}
                 \begin{verbatim}
                    void display_reverse(List *list);
                \end{verbatim}
                \begin{description}
                    \item[Entrée :] Un pointeur sur une structure de liste.
                    \item[Sortie :] Rien.
                \end{description}                
                De même que la procédure précédente, cette fonction va d'abord faire appel à \verb+reverse+ puis afficher les valeurs des chaines de caractère de chaque cellule. La complexité de cette procédure est donc $\Theta(n)$ 
         \section{Détruire la liste}
                 \begin{verbatim}
                    void destruct (List *list);
                \end{verbatim}
                \begin{description}
                    \item[Entrée :] Un pointeur sur une structure de liste.
                    \item[Sortie :] Rien.
                \end{description}                
                Pour terminer cettte étude sur certaines fonctions que nous avons implémentées, la fonction destruct va parcourir la liste et libérer les espaces mémoires alloués dynamiquement au moment de la création des divers éléments composant la liste. Et enfin elle va terminer en libérant l'espace alloué à la structure List.\\
                
                Cette procédure parcours la liste quelque soit le cas on a donc une complexité en $\Theta(n)$.   
                
                \newpage
                
          \chapter{R\'eflexion}	
          
          Vous remarquerez que je n'ai pas pris la peine d'expliciter plusieurs fonctions et je le regrette mais c'est par manque de temps. D'autre part, j'ai juger que ces fonctions ne nécessite pas explicitation car elles ont été codé intuitivement. 
          
          En ce qui concerne les possibilités d'améliorations de notre programme, pour l'instant je ne vois aucun gros changement à apporter qui pourrait modifier drastiquement la complexité de nos procédures. Il y a un changement que j'apporterai néanmoins à la procédure de recherche. Par exemple, quelque soit la position de l'objet que nous souhaitons trouver nous commençons toujours par le début, il faudrait alors pour diviser la complexiter de la procédure par deux rechercher en fonction de l'indice.	                                    
\end{document}
